import type {PluginCreator, Plugin} from 'postcss'
import {resolve} from "path"
import { regexpize, extractDefaults, readlineSync } from './utils'
import schema = require("./schema.json")
import type { Options } from './options.types'
import replaceMultiplicated = require('./replaceMultiplicated')
import collector = require('./collector')
import rewrite = require('./rewrite')

const {keys: $keys} = Object
, defaultOptions = extractDefaults(schema)
, defaultTemplate = readlineSync(resolve(__dirname, "_css-template.d.ts"), "\n")
, signature = ["/** Auto generated by [postcss-plugin-d-ts](https://github.com/askirmas/postcss-plugin-d-ts) */"]

const creator: PluginCreator<Options> = (opts?) => {
  const options = {...defaultOptions, ...opts}
  , {
    eol,
    destination,
    //TODO several keywords?
    identifierKeyword,
    identifierMatchIndex,
    identifierCleanupReplace,
  } = options
  , {
    allowedAtRules,
    identifierParser,
    identifierCleanupParser,
    templateContent
  } = makeOpts(options)

  return {
    postcssPlugin: "postcss-plugin-d-ts",
    prepare: (result) => {
      /* istanbul ignore next `source === undefined` for manually created node */
      if (!result.root.source?.input.file)
        return {}

      try {
        OptsCheck({destination, identifierParser})
      } catch ({message}) {
        result.warn(message, {})
        return {}
      }
      
      //https://jsbench.me/q5km8xdgbb
      const identifiers: Record<string, true> = {}
            
      return {
        RuleExit: collector({
          identifiers,
          identifierParser,
          identifierMatchIndex,
          identifierCleanupParser,
          identifierCleanupReplace,
          allowedAtRules
        }),
        RootExit: writer({
          //@ts-expect-error
          destination,
          eol, identifierKeyword, identifiers, templateContent
        })
      }
    }
  }
}

creator.postcss = true

export = creator

function OptsCheck({
  destination,
  identifierParser
}: {
  destination: any,
  identifierParser: RegExp
}) {
  if (!(destination === false || destination !== null && typeof destination === "object"))
    throw Error("Destination is of wrong type")
  
  //TODO check sticky
  if (!identifierParser.flags.includes('g'))
    throw Error('identifierParser should have global flag')
}

function makeOpts({
  eol,
  template: templatePath,
  identifierPattern: cssP,
  identifierCleanupSearch: escapedP,
  allowedAtRules: atRules  
}: Pick<Required<Options>, "eol"|"template"|"identifierPattern"|"identifierCleanupSearch"|"allowedAtRules">) {
  const identifierParser = regexpize(cssP, "g")
  , identifierCleanupParser = regexpize(escapedP, "g")
  //TODO check `templatePath === ""`
  , templateContent = typeof templatePath === "string"
  ? readlineSync(templatePath, eol)
  : defaultTemplate

  , allowedAtRules = new Set(atRules)

  return {
    identifierParser,
    identifierCleanupParser,
    templateContent,
    allowedAtRules
  }
}

function writer({
  eol,
  templateContent,
  identifierKeyword,
  identifiers,
  destination
}: {
  eol: string
  templateContent: string[]
  identifierKeyword: string
  identifiers: Record<string, any>
  destination: Record<string, string[]> | false
}) {
  return (async ({source}) => {
    const file = source!.input.file!
    , lines = replaceMultiplicated(
      signature.concat(templateContent),
      identifierKeyword,
      $keys(identifiers)
      //TODO Change with option
      .sort()
    )

    if (destination === false)
      await rewrite(`${file}.d.ts`, lines, eol)
    else
      destination[file] = lines
  }) as Exclude<Plugin["RootExit"], undefined>
}