import type {PluginCreator, Plugin} from 'postcss'
import {resolve} from "path"
import { regexpize, extractDefaults, readlineSync } from './utils'
import schema = require("./schema.json")
import type { Options } from './options.types'
import replaceMultiplicated = require('./replaceMultiplicated')
import collector = require('./collector')
import rewrite = require('./rewrite')
import type { InternalOptions } from './$defs.types'

type Opts = Required<Options>

const {keys: $keys} = Object
, defaultOptions = extractDefaults(schema) as Opts
, defaultTemplate = readlineSync(resolve(__dirname, "_css-template.d.ts"), "\n")
, signature = ["/** Auto generated by [postcss-plugin-d-ts](https://github.com/askirmas/postcss-plugin-d-ts) */"]

const creator: PluginCreator<Options> = (opts?) => {
  const options = {...defaultOptions, ...opts}
  , {
    eol,
    destination,
    //TODO several keywords?
    identifierKeyword,
    identifierMatchIndex,
    identifierCleanupReplace,
  } = options
  , {
    allowedAtRuleNames,
    identifierParser,
    identifierCleanupParser,
    //TODO #12 move to `prepare`
    templateContent
  } = makeOpts(options)

  return {
    postcssPlugin: "postcss-plugin-d-ts",
    prepare: (result) => {
      /* istanbul ignore next `source === undefined` for manually created node */
      if (!result.root.source?.input.file)
        return {}

      try {
        OptsCheck({destination, identifierParser})
      } catch ({message}) {
        result.warn(message, {})
        return {}
      }
      
      // https://jsbench.me/q5km8xdgbb
      const identifiers: Record<string, true> = {}
            
      return {
        RuleExit: collector(
          identifiers,
          {
            identifierParser,
            identifierMatchIndex,
            identifierCleanupParser,
            identifierCleanupReplace,
            allowedAtRuleNames
          }),
        RootExit: writer(
          identifiers,
          {
            destination,
            eol,
            identifierKeyword,
            templateContent
          }
        )
      }
    }
  }
}

creator.postcss = true

export = creator

function OptsCheck({
  destination,
  identifierParser
}: {destination: any} & Pick<InternalOptions, "identifierParser">) {
  if (!(destination === false || destination !== null && typeof destination === "object"))
    throw Error("Destination is of wrong type")
  
  //TODO check sticky
  if (!identifierParser.flags.includes('g'))
    throw Error('identifierParser should have global flag')
}

function makeOpts({
  eol,
  template: templatePath,
  identifierPattern: cssP,
  identifierCleanupPattern: escapedP,
  allowedAtRules: atRules  
}: Pick<Opts, "eol"|"template"|"identifierPattern"|"identifierCleanupPattern"|"allowedAtRules">): InternalOptions {
  const identifierParser = regexpize(cssP, "g")
  , identifierCleanupParser = regexpize(escapedP, "g")
  //TODO check `templatePath === ""`
  , templateContent = typeof templatePath === "string"
  // TODO not sync
  ? readlineSync(templatePath, eol)
  : defaultTemplate

  , allowedAtRuleNames = new Set(atRules)

  return {
    identifierParser,
    identifierCleanupParser,
    templateContent,
    allowedAtRuleNames
  }
}

function writer(
  identifiers: Record<string, any>,
  {
    eol,
    templateContent,
    identifierKeyword,
    destination
  }: Pick<Opts, "eol"|"identifierKeyword"|"destination">
  & Pick<InternalOptions, "templateContent">
) {
  return (async ({source}) => {
    const file = source!.input.file!
    , lines = replaceMultiplicated(
      signature.concat(templateContent),
      identifierKeyword,
      $keys(identifiers)
      //TODO Change with option
      .sort()
    )

    if (destination === false)
      await rewrite(`${file}.d.ts`, lines, eol)
    else
      destination[file] = lines
  }) as Exclude<Plugin["RootExit"], undefined>
}