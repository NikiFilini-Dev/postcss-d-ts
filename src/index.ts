import type {PluginCreator} from 'postcss'
import {resolve} from "path"
import { regexpize, extractDefaults, readlineSync } from './utils'
import schema = require("./schema.json")
import type { Options, jsOptions } from './options.types'
import replaceMultiplicated = require('./replaceMultiplicated')
import collector = require('./collector')
import rewrite = require('./rewrite')

const {keys: $keys} = Object
, defaultOptions = extractDefaults(schema)
, defaultTemplate = readlineSync(resolve(__dirname, "_css-template.d.ts"), "\n")
, signature = ["/** Auto generated by [postcss-plugin-d-ts](https://github.com/askirmas/postcss-plugin-d-ts) */"]

const creator: PluginCreator<Options> = (opts?) => {
  const {
    eol,
    destination,
    template: templatePath,
    //TODO several keywords?
    identifierKeyword,
    identifierPattern: cssP,
    identifierMatchIndex,
    identifierCleanupSearch: escapedP,
    identifierCleanupReplace,
    allowedAtRules: atRules

  } = {...defaultOptions, ...opts}
  , identifierParser = regexpize(cssP, "g")
  , identifierCleanupParser = regexpize(escapedP, "g")
  //TODO check `templatePath === ""`
  , templateContent = typeof templatePath === "string"
  ? readlineSync(templatePath, eol)
  : defaultTemplate

  const allowedAtRules = new Set(atRules)

  return {
    postcssPlugin: "postcss-plugin-d-ts",
    prepare: (result) => {
      if (!destination && destination !== false) {
        result.warn("Destination is falsy")
        return {}
      }
      //TODO check sticky
      if (!identifierParser.flags.includes('g')) {
        result.warn('identifierParser should have global flag')
        return {}
      }

        //TODO https://jsbench.me/q5km8xdgbb
      const identifiers: Record<string, true> = {}
      
      let file: string|undefined
      
      return {
        Once: ({source}) => {
          /* istanbul ignore next `source === undefined` for manually created node */
          file = source?.input.file
        },
        RuleExit: arg => !file ? void 0 : collector({
          identifiers,
          identifierParser,
          identifierMatchIndex,
          identifierCleanupParser,
          identifierCleanupReplace,
          allowedAtRules
        })(arg),
        RootExit: async () => {
          if (!file)
            return
          const lines = replaceMultiplicated(
            signature.concat(templateContent),
            identifierKeyword,
            $keys(identifiers)
            //TODO Change with option
            .sort()
          )
          if (destination === false)
            await rewrite(`${file}.d.ts`, lines, eol)
          else
            // TODO Somehow get rid of `{}`
            (destination as jsOptions["destination"])[
              file
            ] = lines
        }
      }
    }
  }
}

creator.postcss = true


export = creator